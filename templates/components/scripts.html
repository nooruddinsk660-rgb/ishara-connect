<!-- Load Socket.IO from CDN -->
<script src="https://cdn.socket.io/4.6.0/socket.io.min.js"
    integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+"
    crossorigin="anonymous"></script>

<script>
    // --- Global States ---
    let isPoliteMode = false;
    let isMuted = false;
    let isCameraOn = true;
    let lastPlayedAudioUrl = "";
    let selectedLang = 'english';
    let socket = null;
    let localStream = null;
    let cameraInterval = null;
    let isFrameProcessing = false;

    // --- Audio Manager ---
    const AppManager = {
        isAudioPlaying: false,
        wasMicActiveBeforeAudio: false,
        audioCache: {},

        preloadAudio: function () {
            // Preload common polite greetings
            const common = [
                '/static/audio/bengali_polite/hello_polite.mp3',
                '/static/audio/hindi_polite/hello_polite.mp3',
                '/static/audio/english_polite/hello_polite.mp3'
            ];
            common.forEach(url => {
                const audio = new Audio();
                audio.src = url;
                this.audioCache[url] = audio;
            });
            console.log("‚¨áÔ∏è Audio Preloaded");
        },

        playAudio: function (url) {
            if (isMuted || this.isAudioPlaying) return;

            console.log("üîä Playing audio:", url);
            this.isAudioPlaying = true;

            // Stop Mic if it's running to avoid self-loop
            if (SpeechManager.isListening) {
                this.wasMicActiveBeforeAudio = true;
                SpeechManager.stopListening();
            }

            const audio = new Audio(url);

            audio.onended = () => {
                this.isAudioPlaying = false;
                lastPlayedAudioUrl = "";
                // Auto-resume mic if it was active?
                // UX Decision: Typically users want to reply after hearing, so manual toggle is safer 
                // to avoid picking up echo, but we can auto-resume if desired. 
                // For now, let's keep it manual or auto-resume with delay.
                if (this.wasMicActiveBeforeAudio) {
                    this.wasMicActiveBeforeAudio = false;
                    // setTimeout(() => SpeechManager.startListening(), 500); // Optional Auto-Resume
                }
            };

            audio.onerror = (e) => {
                console.error("‚ùå Audio playback failed:", e);
                this.isAudioPlaying = false;
            };

            audio.play().catch(e => {
                console.warn("‚ö†Ô∏è Autoplay blocked:", e);
                this.isAudioPlaying = false;
            });
        }
    };

    // --- Speech Recognition Manager (World Class Refactor) ---
    const SpeechManager = {
        recognition: null,
        isListening: false,
        finalTranscript: '',

        init: function () {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                this.recognition.continuous = false; // We want single command/sentence flow
                this.recognition.interimResults = true; // Show text AS you speak
                this.recognition.maxAlternatives = 1;

                this.setupListeners();
            } else {
                console.error("‚ùå Speech Recognition Not Supported in this Browser.");
                alert("Speech Recognition is not supported in this browser. Please use Chrome.");
                const btn = document.getElementById('listen-btn');
                if (btn) btn.style.display = 'none';
            }
        },

        setupListeners: function () {
            if (!this.recognition) return;

            this.recognition.onstart = () => {
                this.isListening = true;
                this.updateUI(true);
                console.log("üé§ Mic Started");
            };

            this.recognition.onend = () => {
                this.isListening = false;
                this.updateUI(false);
                console.log("üé§ Mic Stopped");

                // If we have a final transcript, we can "process" it here if needed
                if (this.finalTranscript.trim() !== '') {
                    setTimeout(() => {
                        this.toggleOverlay(false);
                    }, 1500);
                } else {
                    this.toggleOverlay(false);
                    const incomingDisplay = document.getElementById('incoming-text');
                    if (incomingDisplay) incomingDisplay.style.display = 'none';
                }
            };

            this.recognition.onresult = (event) => {
                let interimTranscript = '';
                this.finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        this.finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                // Update Overlay Text
                const transcriptDisplay = document.getElementById('active-transcript');
                if (transcriptDisplay) {
                    transcriptDisplay.innerHTML = `
                        <span style="color:white;">${this.finalTranscript}</span>
                        <span style="color:rgba(255,255,255,0.6);">${interimTranscript}</span>
                    `;
                }

                // Update original Dashboard Text 
                const incomingDisplay = document.getElementById('incoming-text');
                if (incomingDisplay) {
                    incomingDisplay.style.setProperty('display', 'block', 'important');
                    incomingDisplay.innerText = this.finalTranscript || interimTranscript;
                }

                console.log("üó£Ô∏è Speech:", this.finalTranscript || interimTranscript);
            };

            this.recognition.onerror = (event) => {
                console.error("‚ùå Speech Error:", event.error);
                let msg = "Error occurred";
                if (event.error === 'no-speech') msg = "No speech detected. Try again.";
                if (event.error === 'network') msg = "Network error. Check connection.";
                if (event.error === 'not-allowed') msg = "Microphone access denied.";

                const title = document.getElementById('listening-title');
                if (title) title.innerText = msg;

                // Keep overlay for a moment to show error
                setTimeout(() => {
                    if (this.isListening) this.stopListening();
                    this.toggleOverlay(false);
                }, 2000);
            };
        },

        startListening: function () {
            if (!this.recognition) return;
            if (this.isListening) return;

            this.finalTranscript = ''; // Reset

            // Set Language Logic
            let micLang = 'en-US';
            if (selectedLang === 'hindi') micLang = 'hi-IN';
            if (selectedLang === 'bengali') micLang = 'bn-IN';
            this.recognition.lang = micLang;
            console.log("üåê Setting Mic Language to:", micLang);

            // Update user hint logic based on Polite Mode? -> No, standard recognition is fine.
            // Polite mode affects OUTPUT, not input recognition usually.

            this.toggleOverlay(true);
            try {
                this.recognition.start();
            } catch (e) { console.error(e); }
        },

        stopListening: function () {
            if (!this.recognition) return;
            this.recognition.stop();
        },

        toggleListening: function () {
            if (this.isListening) {
                this.stopListening();
            } else {
                this.startListening();
            }
        },

        toggleOverlay: function (show) {
            const overlay = document.getElementById('listening-overlay');
            const title = document.getElementById('listening-title');
            const transcript = document.getElementById('active-transcript');

            if (overlay) {
                if (show) {
                    overlay.classList.add('active');
                    if (title) title.innerText = "Listening...";
                    if (transcript) transcript.innerText = "";
                } else {
                    overlay.classList.remove('active');
                }
            }
        },

        updateUI: function (active) {
            const listenBtn = document.getElementById('listen-btn');
            if (listenBtn) {
                if (active) {
                    listenBtn.classList.add('listening');
                    listenBtn.innerHTML = '<i class="fas fa-wave-square"></i> &nbsp; Listening...';
                } else {
                    listenBtn.classList.remove('listening');
                    listenBtn.innerHTML = '<i class="fas fa-microphone"></i> &nbsp; Listen to Reply';
                }
            }
        }
    };


    // --- INIT ---
    document.addEventListener('DOMContentLoaded', () => {
        // 0. Sync Language State
        const langSelect = document.getElementById('language-select');
        if (langSelect) selectedLang = langSelect.value;

        // 1. Socket Init
        socket = io();

        socket.on('connect', () => {
            console.log("‚ö° Connected to Server via WebSockets");
            emitSettings();
        });

        socket.on('disconnect', () => {
            console.log("üîå Disconnected");
        });

        socket.on('prediction_update', (data) => {
            const predElement = document.getElementById('pred-text');
            const sentElement = document.getElementById('sent-text');

            if (data.prediction && data.prediction !== "Nothing") {
                if (predElement) predElement.innerText = data.prediction;
                if (sentElement) sentElement.innerText = data.sentence;

                document.querySelectorAll('.gesture-icon').forEach(el => el.classList.remove('active'));
                const activeIcon = document.getElementById('icon-' + data.prediction);
                if (activeIcon) {
                    activeIcon.classList.add('active');
                    activeIcon.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            }
        });

        socket.on('play_audio', (data) => {
            if (data.audio_url) AppManager.playAudio(data.audio_url);
        });

        // Backend returning drawn frames
        socket.on('processed_frame', (data) => {
            isFrameProcessing = false;
            if (isCameraOn) {
                const img = document.getElementById('video_feed');
                if (img) img.src = data;
            }
        });

        // 2. Preload
        AppManager.preloadAudio();

        // 3. Permissions Check
        checkPermissions();

        // 4. Init Theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'light') {
            toggleTheme(false); // Apply light without toggling
        }

        // 5. Init Speech
        SpeechManager.init();
    });

    function checkPermissions() {
        // Explicitly request front-facing camera on mobile. 
        // Do NOT request audio here! The Web Speech API needs exclusive access to the mic on mobile.
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false })
            .then(stream => {
                console.log("‚úÖ Camera Access Granted (Mic will be requested on-demand)");
                localStream = stream;
                const localVideo = document.getElementById('local_video');
                if (localVideo) {
                    localVideo.srcObject = stream;
                    localVideo.play();
                }

                startFrameStreaming();
            })
            .catch(err => {
                console.error("‚ùå Permission Denied:", err);
                const overlay = document.createElement('div');
                overlay.innerHTML = `
                <div style="position:fixed;top:0;left:0;width:100%;height:100%;
                            background:rgba(0,0,0,0.9);z-index:10000;display:flex;
                            justify-content:center;align-items:center;flex-direction:column;
                            text-align:center;color:white;padding:20px;">
                    <i class="fas fa-lock" style="font-size:4rem;color:#ff4757;margin-bottom:20px;"></i>
                    <h1>Camera/Mic Access Blocked</h1>
                    <p style="font-size:1.2rem;margin-bottom:20px;">Please allow camera and microphone access.</p>
                    <button onclick="location.reload()" 
                            style="padding:10px 30px;font-size:1.2rem;border:none;border-radius:50px;
                                   background:var(--accent-primary);color:white;cursor:pointer;">
                        Try Again
                    </button>
                </div>
            `;
                document.body.appendChild(overlay);
            });
    }

    function startFrameStreaming() {
        const localVideo = document.getElementById('local_video');
        const hiddenCanvas = document.getElementById('hidden_canvas');
        if (!localVideo || !hiddenCanvas) return;

        const context = hiddenCanvas.getContext('2d');

        // Process frames carefully to avoid network congestion
        cameraInterval = setInterval(() => {
            if (isCameraOn && socket && socket.connected && localVideo.readyState >= 2 && !isFrameProcessing) {
                isFrameProcessing = true;
                hiddenCanvas.width = localVideo.videoWidth;
                hiddenCanvas.height = localVideo.videoHeight;
                context.drawImage(localVideo, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

                // Compress highly: speed > quality for ML coordinates
                const dataURL = hiddenCanvas.toDataURL('image/jpeg', 0.5);
                socket.emit('video_frame', dataURL);
            }
        }, 80); // Send next frame roughly ~12fps max
    }

    function emitSettings() {
        const lang = document.getElementById('language-select')?.value || 'english';
        const polite = document.getElementById('polite-toggle')?.checked || false;
        socket.emit('update_settings', { lang: lang, polite: polite });
    }

    // --- UI Logic ---
    // Start Overlay Unlock
    document.getElementById('start-overlay')?.addEventListener('click', function () {
        this.style.display = 'none';
        new Audio().play().catch(e => { }); // Unlock Audio Context
    });

    // 1. Language Change (Refined with Pulse Animation)
    function onLanguageChange(select) {
        selectedLang = select.value;
        emitSettings();

        // Visual Pulse Effect
        select.classList.add('language-pulse');
        setTimeout(() => select.classList.remove('language-pulse'), 500);

        // Toast Notification (Optional but good for feedback)
        // console.log("üåê Language Switched to:", selectedLang);

        // If listening, restart to apply new language
        if (SpeechManager.isListening) {
            SpeechManager.stopListening();
            setTimeout(() => SpeechManager.startListening(), 500);
        }
    }
    document.getElementById('language-select')?.addEventListener('change', (e) => onLanguageChange(e.target));


    // 2. Polite Toggle (Refined with Golden Glow)
    function togglePolite() {
        const checkbox = document.getElementById('polite-toggle');
        if (checkbox) {
            isPoliteMode = checkbox.checked;
            const wrapper = document.getElementById('polite-wrapper');

            if (wrapper) {
                if (isPoliteMode) {
                    wrapper.classList.add('active');
                    // Add a temporary scale bump
                    wrapper.style.transform = "scale(1.1)";
                    setTimeout(() => wrapper.style.transform = "scale(1.02)", 200);
                } else {
                    wrapper.classList.remove('active');
                    wrapper.style.transform = "scale(1)";
                }
            }
            emitSettings();
        }
    }

    // 3. Theme Toggle
    function toggleTheme(doToggle = true) {
        const body = document.body;
        const icon = document.getElementById('theme-icon');
        let isLight = body.getAttribute('data-theme') === 'light';

        if (doToggle) isLight = !isLight;

        if (isLight) {
            body.setAttribute('data-theme', 'light');
            if (icon) { icon.classList.remove('fa-sun'); icon.classList.add('fa-moon'); }
            localStorage.setItem('theme', 'light');
        } else {
            body.removeAttribute('data-theme');
            if (icon) { icon.classList.remove('fa-moon'); icon.classList.add('fa-sun'); }
            localStorage.setItem('theme', 'dark');
        }
    }

    // 4. Camera Toggle
    function toggleCamera() {
        const btn = document.getElementById('camera-toggle');
        const icon = btn ? btn.querySelector('i') : null;
        isCameraOn = !isCameraOn;

        if (isCameraOn) {
            if (icon) {
                icon.classList.remove('fa-video-slash');
                icon.classList.add('fa-video');
                btn.classList.remove('is-off');
            }
        } else {
            const videoFeed = document.getElementById('video_feed');
            if (videoFeed) {
                videoFeed.style.opacity = "0";
                setTimeout(() => { videoFeed.src = ""; }, 300);
            }
            if (icon) {
                icon.classList.remove('fa-video');
                icon.classList.add('fa-video-slash');
                btn.classList.add('is-off');
            }
        }
    }

    // 5. Sound Toggle
    function toggleSound() {
        const btn = document.getElementById('sound-toggle');
        const icon = btn ? btn.querySelector('i') : null;
        isMuted = !isMuted;
        if (isMuted) {
            if (icon) {
                icon.classList.remove('fa-volume-up');
                icon.classList.add('fa-volume-mute');
                btn.classList.add('is-off');
            }
        } else {
            if (icon) {
                icon.classList.remove('fa-volume-mute');
                icon.classList.add('fa-volume-up');
                btn.classList.remove('is-off');
            }
        }
    }

    // 6. Flashlight Toggle
    function toggleFlashlight() {
        const overlay = document.getElementById('flashlight-overlay');
        if (overlay) {
            overlay.style.display = (overlay.style.display === 'flex') ? 'none' : 'flex';
        }
        fetch('/log_event?msg=FlashlightToggled');
    }

    // 7. Toggle Listening (Main Function)
    function toggleListening() {
        SpeechManager.toggleListening();
    }

    // 8. Play Gesture (Manual)
    function playGesture(gestureName) {
        const langSelect = document.getElementById('language-select');
        if (langSelect) selectedLang = langSelect.value;

        console.log("üëÜ Manual Gesture Click:", gestureName, "Lang:", selectedLang);

        let folder = selectedLang;
        let filename = gestureName.toLowerCase().replace(/ /g, '_');

        if (isPoliteMode) {
            folder += '_polite';
            filename += '_polite';
        }

        const url = `/static/audio/${folder}/${filename}.mp3`;
        AppManager.playAudio(url);

        // Visual Feedback
        const iconId = 'icon-' + gestureName;
        const icon = document.getElementById(iconId);
        if (icon) {
            icon.classList.add('active');
            setTimeout(() => icon.classList.remove('active'), 1000);
        }
        const predText = document.getElementById('pred-text');
        if (predText) predText.innerText = gestureName;
    }
</script>